<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Shoot The Image — Laser Slice Mode 2</title>
<style>
  :root{--bg:#0b0b0b;--accent:#ff3b3b;--muted:#ddd}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--muted);font-family:Inter,Arial,Helvetica,sans-serif;overflow:hidden}
  .ui-top{
    position:fixed;left:0;right:0;top:12px;pointer-events:none;
    text-align:center;font-size:18px;line-height:1.2;
    text-shadow:0 0 12px rgba(0,0,0,.8);
  }
  .ui-top .line{pointer-events:none}
  .container{
    position:relative;width:100%;height:100vh;display:flex;align-items:center;justify-content:center;
  }

  /* target image */
  .target-wrap{
    position:relative;
    width:320px; max-width:80vw;
    touch-action:none;
  }
  img.target{
    display:block;
    width:100%;
    height:auto;
    user-select:none;
    -webkit-user-drag:none;
    pointer-events:none;
    border-radius:12px;
    transform-origin:center;
    box-shadow:0 8px 30px rgba(0,0,0,.6), inset 0 0 40px rgba(0,0,0,.25);
  }

  /* laser canvas overlay */
  canvas.overlay{
    position:absolute;left:0;top:0;right:0;bottom:0;width:100%;height:100%;
    pointer-events:auto;
    border-radius:12px;
  }

  /* pieces layer */
  .pieces{
    position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;
  }
  .piece{
    position:absolute;left:0;top:0;will-change:transform,opacity;
    transform-origin:center;
    pointer-events:none;
  }

  /* bullet flash */
  .bullet{position:fixed;width:8px;height:8px;border-radius:50%;background:yellow;pointer-events:none;mix-blend-mode:screen;filter:blur(0.6px);}

  /* scorch overlay (subtle) */
  .scorch{
    position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;border-radius:12px;
    mix-blend-mode:multiply;opacity:0;transition:opacity .4s;
    background:radial-gradient(circle at 10% 10%, rgba(0,0,0,0.35), transparent 40%),
               radial-gradient(circle at 80% 60%, rgba(40,0,0,0.15), transparent 35%);
  }

  /* tiny debug */
  .credits{position:fixed;left:12px;bottom:12px;font-size:12px;opacity:.6}
</style>
</head>
<body>

<div class="ui-top">
  <div class="line">hit ur fineshytt if u are mad</div>
  <div class="line" style="font-size:14px;margin-top:6px">sentuh untuk tembk bijinya · sentuh seret untuk menggunakan laser biji</div>
</div>

<div class="container">
  <div class="target-wrap" id="wrap">
    <!-- change src to your image -->
    <img id="targetImg" class="target" src="https://miyamurajo-bot.github.io/hit_me/muka.jpg" crossorigin="anonymous" alt="target">
    <canvas class="overlay" id="overlay"></canvas>
    <div class="scorch" id="scorch"></div>
    <div class="pieces" id="pieces"></div>
  </div>
</div>

<div class="credits">laser: thin neon (A) · mode: chaotic shards (Mode 2)</div>

<script>
/* ===========================
   Config
   =========================== */
const LASER_COLOR = '#ff3b3b';          // neon red
const LASER_GLOW = 'rgba(255,59,59,0.16)';
const LASER_WIDTH = 4;                  // thin laser
const SHARD_MIN = 3;
const SHARD_MAX = 6;
const GRAVITY = 1200;                   // px/s^2
const FALL_DRAG = 0.998;
const ROTATION_RANGE = 6;               // deg/s initial
const AUDIO_SHOT = "https://raw.githubusercontent.com/miyamurajo-bot/hit_me/raw/main/m4a1_single-kibblesbob-8540445.mp3";
const AUDIO_LASER = null; // if you want a laser sound URL, put here

/* ===========================
   Elements & sizing
   =========================== */
const wrap = document.getElementById('wrap');
const img = document.getElementById('targetImg');
const overlay = document.getElementById('overlay');
const piecesLayer = document.getElementById('pieces');
const scorch = document.getElementById('scorch');

let dpr = Math.max(1, window.devicePixelRatio || 1);
function resizeCanvas(){
  const rect = wrap.getBoundingClientRect();
  overlay.width = Math.round(rect.width * dpr);
  overlay.height = Math.round(rect.height * dpr);
  overlay.style.width = rect.width + 'px';
  overlay.style.height = rect.height + 'px';
  overlay.getContext('2d').setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', resizeCanvas);
img.addEventListener('load', resizeCanvas);

/* ===========================
   Bullet / Shooting
   =========================== */
function playShoot(){
  const a = new Audio(AUDIO_SHOT);
  a.volume = 0.35;
  a.play().catch(()=>{/* silence */});
}
function spawnBullet(x,y){
  const b = document.createElement('div');
  b.className='bullet';
  document.body.appendChild(b);
  b.style.left = (x-4)+'px';
  b.style.top  = (y-4)+'px';
  b.style.opacity = '1';
  setTimeout(()=> b.remove(),200);
}

/* ===========================
   Laser draw + slicing flow
   =========================== */
const ctx = overlay.getContext('2d');
let drawing = false;
let path = []; // array of {x,y} relative to wrap
function toLocal(e){
  const r = wrap.getBoundingClientRect();
  const p = (e.touches && e.touches[0]) ? e.touches[0] : e;
  return { x: p.clientX - r.left, y: p.clientY - r.top };
}
function start(e){
  const p = toLocal(e);
  // only start if point is within image area
  if(p.x < 0 || p.y < 0 || p.x > overlay.width/dpr || p.y > overlay.height/dpr) return;
  drawing = true;
  path = [{x:p.x, y:p.y}];
  drawOverlay();
  if(AUDIO_LASER){
    const s = new Audio(AUDIO_LASER); s.volume=0.4; s.play().catch(()=>{});
  }
}
function move(e){
  if(!drawing) return;
  e.preventDefault();
  const p = toLocal(e);
  path.push({x:p.x, y:p.y});
  // keep path length reasonable
  if(path.length > 120) path.shift();
  drawOverlay();
}
function end(e){
  if(!drawing) return;
  drawing = false;
  drawOverlay(true);
  // produce shards
  if(path.length > 2) createShardsFromPath(path);
  // add scorch briefly
  scorch.style.opacity = '1';
  setTimeout(()=>scorch.style.opacity='0',700);
  path = [];
}

/* draw laser line */
function drawOverlay(final=false){
  const w = overlay.width/dpr, h = overlay.height/dpr;
  ctx.clearRect(0,0,w,h);

  // glow
  if(path.length>0){
    ctx.save();
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    // outer glow
    ctx.strokeStyle = LASER_GLOW;
    ctx.lineWidth = LASER_WIDTH*5;
    ctx.beginPath();
    path.forEach((pt,i)=> i?ctx.lineTo(pt.x,pt.y):ctx.moveTo(pt.x,pt.y));
    ctx.stroke();
    // core
    ctx.strokeStyle = LASER_COLOR;
    ctx.lineWidth = LASER_WIDTH;
    ctx.beginPath();
    path.forEach((pt,i)=> i?ctx.lineTo(pt.x,pt.y):ctx.moveTo(pt.x,pt.y));
    ctx.stroke();

    // small sparks
    for(let i=0;i<Math.min(10, path.length); i++){
      const idx = Math.floor(Math.random()*path.length);
      const p = path[idx];
      ctx.fillStyle = 'rgba(255,200,150,'+ (Math.random()*0.6) +')';
      ctx.fillRect(p.x + (Math.random()-0.5)*6, p.y + (Math.random()-0.5)*6, 2,2);
    }
    ctx.restore();
  }

  if(final && path.length>1){
    // final bright flash
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.strokeStyle = 'rgba(255,255,255,0.25)';
    ctx.lineWidth = LASER_WIDTH*2;
    ctx.beginPath();
    path.forEach((pt,i)=> i?ctx.lineTo(pt.x,pt.y):ctx.moveTo(pt.x,pt.y));
    ctx.stroke();
    ctx.restore();
  }
}

/* ===========================
   Create shards & animate pieces
   =========================== */
function createShardsFromPath(pathPoints){
  // number of shards
  const N = Math.floor(Math.random()*(SHARD_MAX-SHARD_MIN+1)) + SHARD_MIN;
  const rect = img.getBoundingClientRect();
  const imgW = Math.round(rect.width);
  const imgH = Math.round(rect.height);

  // create an offscreen canvas to sample image contents
  const srcCanvas = document.createElement('canvas');
  srcCanvas.width = imgW; srcCanvas.height = imgH;
  const sctx = srcCanvas.getContext('2d');
  // draw image scaled to canvas
  // using drawImage with natural size mapping to display size
  sctx.drawImage(img, 0, 0, imgW, imgH);

  // generate vertical-ish shard polygons across width with jagged edges influenced by path
  const sliceXs = [];
  for(let i=0;i<=N;i++){
    const t = i/N;
    // jitter to make shards irregular
    const jitter = (Math.random()-0.5) * imgW * 0.08;
    sliceXs.push(Math.max(0, Math.min(imgW, Math.round(t*imgW + jitter))));
  }
  // ensure sorted and unique boundaries
  sliceXs.sort((a,b)=>a-b);
  // produce polygon for each slice with path cut applied
  const pieces = [];
  for(let i=0;i<N;i++){
    const x0 = sliceXs[i], x1 = sliceXs[i+1] || imgW;
    // create polygon polygon points along top and bottom
    const poly = [];
    // top edge from x0 -> x1, optionally nudge by path influence
    const segCount = 6;
    for(let k=0;k<=segCount;k++){
      const u = k/segCount;
      const x = Math.round(x0 + (x1-x0)*u);
      // sample path to get an offset (simulate laser cut line)
      // find nearest path point horizontally mapped to image rect
      let best = 0;
      for(const pp of pathPoints){
        const rx = pp.x * (imgW/overlay.width*dpr) || pp.x;
        // using relative mapping: overlay is same visual size as image inside wrap
      }
      // produce small top/bottom sinus jitter based on path and noise
      const topJ = Math.sin((x/imgW)*Math.PI*4 + Math.random()*2) * 4;
      const bottomJ = Math.sin((x/imgW)*Math.PI*3 + Math.random()*2) * 6;
      poly.push({x, y: 0 + topJ});
    }
    // bottom edge reversed
    for(let k=segCount;k>=0;k--){
      const u = k/segCount;
      const x = Math.round(x0 + (x1-x0)*u);
      const topJ = Math.sin((x/imgW)*Math.PI*4 + Math.random()*2) * 4;
      const bottomJ = Math.sin((x/imgW)*Math.PI*3 + Math.random()*2) * 6;
      poly.push({x, y: imgH + bottomJ});
    }
    pieces.push({poly, x0, x1});
  }

  // For each piece, create a canvas clipped to polygon and convert to image element
  pieces.forEach((pc, idx) => {
    const c = document.createElement('canvas');
    c.width = imgW; c.height = imgH;
    const cc = c.getContext('2d');

    // clip to polygon
    cc.save();
    cc.beginPath();
    pc.poly.forEach((pt,i)=> i?cc.lineTo(pt.x, pt.y):cc.moveTo(pt.x, pt.y));
    cc.closePath();
    cc.clip();

    // draw image
    cc.drawImage(img, 0, 0, imgW, imgH);
    cc.restore();

    // create DOM element showing this canvas
    const data = c.toDataURL();
    const el = document.createElement('img');
    el.src = data;
    el.className = 'piece';
    // size & position relative to wrap
    el.style.width = imgW + 'px';
    el.style.height = imgH + 'px';
    el.style.left = '0px';
    el.style.top = '0px';
    piecesLayer.appendChild(el);

    // initial transform: slightly separate pieces around laser path
    const centerX = (pc.x0 + pc.x1)/2;
    const offsetX = (centerX - imgW/2) * 0.05 + (Math.random()-0.5)*20;
    const offsetY = (Math.random()-0.5)*10;

    // physics state
    const state = {
      el,
      x: offsetX,
      y: offsetY,
      vx: (Math.random()-0.5) * 600, // px/s
      vy: -Math.random()*300 - 100,  // initial up velocity
      ang: (Math.random()-0.5)*0.5,  // radians
      av: (Math.random()-0.5)*4,     // rad/s
      opacity: 1,
      width: imgW,
      height: imgH,
      pivotX: imgW/2,
      pivotY: imgH/2,
      life: 0
    };

    // apply small scorch/edge darkening by drawing stroke along polygon edges
    const edgeCanvas = document.createElement('canvas');
    edgeCanvas.width = imgW; edgeCanvas.height = imgH;
    const ec = edgeCanvas.getContext('2d');
    ec.drawImage(c,0,0);
    ec.globalCompositeOperation = 'multiply';
    ec.fillStyle = 'rgba(0,0,0,0.06)';
    ec.beginPath();
    pc.poly.forEach((pt,i)=> i?ec.lineTo(pt.x,pt.y):ec.moveTo(pt.x,pt.y));
    ec.closePath();
    ec.fill();
    el.src = edgeCanvas.toDataURL();

    // animate by frame loop registration
    animatePiece(state);
  });

  // hide original image (simulate it got sliced)
  img.style.visibility = 'hidden';
}

/* ===========================
   Animation loop for pieces
   =========================== */
const animStates = new Set();
let lastTime = performance.now();
function animatePiece(state){
  animStates.add(state);
  // we attach state to element for reference
  state.start = performance.now();
  state.frame = function(now){
    const dt = (now - (state._t || now))/1000;
    state._t = now;
    state.life += dt;
    // physics
    state.vy += GRAVITY * dt;
    state.vx *= FALL_DRAG;
    state.vy *= FALL_DRAG;
    state.x += state.vx * dt;
    state.y += state.vy * dt;
    state.ang += state.av * dt * (Math.random()<0.5?1:-1);

    // apply transform
    const tx = `translate(${state.x}px, ${state.y}px) rotate(${state.ang}rad)`;
    state.el.style.transform = tx;
    state.el.style.opacity = Math.max(0, 1 - state.life/6);

    // if below viewport, remove after some time
    const rect = state.el.getBoundingClientRect();
    if(rect.top > window.innerHeight + 200){
      state.el.remove();
      animStates.delete(state);
    } else {
      requestAnimationFrame(state.frame);
    }
  };
  requestAnimationFrame(state.frame);
}

/* ===========================
   Input wiring
   =========================== */
wrap.addEventListener('mousedown', (e)=>{ start(e); playShoot(); spawnBullet(e.clientX, e.clientY); });
wrap.addEventListener('touchstart', (e)=>{ start(e); playShoot(); spawnBullet(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
window.addEventListener('mousemove', move);
window.addEventListener('touchmove', move, {passive:false});
window.addEventListener('mouseup', end);
window.addEventListener('touchend', end);
window.addEventListener('touchcancel', end);

/* allow clicking to shoot normally (no slice) */
document.addEventListener('click', (e)=>{
  const r = wrap.getBoundingClientRect();
  if(e.clientX >= r.left && e.clientX <= r.right && e.clientY >= r.top && e.clientY <= r.bottom){
    spawnBullet(e.clientX, e.clientY);
    playShoot();
    // hit feedback
    img.classList.add('hit');
    setTimeout(()=> img.classList.remove('hit'),150);
  }
});

/* Put back original image after a while if you want (or keep it hidden) */
/* For better UX, we restore original after 6s */
function restoreOriginalAfterDelay(delay=6000){
  setTimeout(()=>{
    // clear pieces
    piecesLayer.innerHTML = '';
    img.style.visibility = 'visible';
  }, delay);
}

/* call resize initially */
resizeCanvas();

/* optional: restore after 8s each time user slices */
let lastSlice = 0;
function createShardsFromPathWrapper(pathPoints){
  createShardsFromPath(pathPoints);
  lastSlice = performance.now();
  restoreOriginalAfterDelay(7000);
}

/* override earlier create call to wrapper with restore */
createShardsFromPath = createShardsFromPathWrapper;

/* Prevent selection on long touch */
document.addEventListener('selectstart', e=>e.preventDefault());
</script>
